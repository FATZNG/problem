# 算法
## 排序
### 冒泡算法
```
描述：每次从头开，比较和后一个的大小，大于后面，则交换位置
```
gif
![avart](../Algorithm/Img/bubbleSort.gif)

### 选择排序
```
每次从后面选取最小值，并交换位置
```
![avart](../Algorithm/Img/selectionSort.gif)

### 快速排序
```
这里用到了递归和分治的思想，还不是很熟练，需要多加练习
php：设定一个基准数，比如arr[0]，把比他大和比他小的分别放进两个数组。并对这两个数组分别进行递归调用。注意一个小细节就是，在两个数组递归的中间应该把刚才的基准数放进去。
go：每一次一数组的第一个数作为基准，还有一个额外的指针a指向基准数的后一个，指针b往后面移动，当b指向的值小于基准数时，
b和指针a互换值，指针a向后移动一步（因为不是插入，但是需要交换值，只有a往后面移动一步，才能和b交换值）。b继续移动。直到最后，基准数和指针a交换位置
```
![avart](../Algorithm/Img/quickSort.gif)

## 双指针
### 蓄水池问题
```
找出最大能蓄水的量，容器不能倾斜
```
![avart](../Algorithm/Img/container-with-most-water.jpg)


## 数组
### 寻找数组的中心下标
```
即找到一个标记，使得标记左边的和等于标记右边的和。如果左边的和为0，则标记为数组最后一个值。右边同理。找出最靠近左边的值
思路：1：最开始想的是从中间开始找，如果没谁小就往谁那边移动，到临界了就又从中间往另一边找（有问题，没写出来）
    2：找到中间位置，然后先往左边走，如果左边有值就跳出循环，没有继续往右边走，（也没写出来）
    3：直接从最开始的位置开始遍历，如果相等则记录（上面也一样）。右边除了索引的右边的和，左边是除了索引的左边的和。每次移动，就左加右减。
```

